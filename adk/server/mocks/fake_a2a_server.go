// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/gin-gonic/gin"
	"github.com/inference-gateway/a2a/adk"
	"github.com/inference-gateway/a2a/adk/server"
)

type FakeA2AServer struct {
	GetAgentCardStub        func() adk.AgentCard
	getAgentCardMutex       sync.RWMutex
	getAgentCardArgsForCall []struct {
	}
	getAgentCardReturns struct {
		result1 adk.AgentCard
	}
	getAgentCardReturnsOnCall map[int]struct {
		result1 adk.AgentCard
	}
	ProcessTaskStub        func(context.Context, *adk.Task, *adk.Message) (*adk.Task, error)
	processTaskMutex       sync.RWMutex
	processTaskArgsForCall []struct {
		arg1 context.Context
		arg2 *adk.Task
		arg3 *adk.Message
	}
	processTaskReturns struct {
		result1 *adk.Task
		result2 error
	}
	processTaskReturnsOnCall map[int]struct {
		result1 *adk.Task
		result2 error
	}
	SetupRouterStub        func(server.OIDCAuthenticator) *gin.Engine
	setupRouterMutex       sync.RWMutex
	setupRouterArgsForCall []struct {
		arg1 server.OIDCAuthenticator
	}
	setupRouterReturns struct {
		result1 *gin.Engine
	}
	setupRouterReturnsOnCall map[int]struct {
		result1 *gin.Engine
	}
	StartStub        func(context.Context) error
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		arg1 context.Context
	}
	startReturns struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	StartTaskProcessorStub        func(context.Context)
	startTaskProcessorMutex       sync.RWMutex
	startTaskProcessorArgsForCall []struct {
		arg1 context.Context
	}
	StopStub        func(context.Context) error
	stopMutex       sync.RWMutex
	stopArgsForCall []struct {
		arg1 context.Context
	}
	stopReturns struct {
		result1 error
	}
	stopReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeA2AServer) GetAgentCard() adk.AgentCard {
	fake.getAgentCardMutex.Lock()
	ret, specificReturn := fake.getAgentCardReturnsOnCall[len(fake.getAgentCardArgsForCall)]
	fake.getAgentCardArgsForCall = append(fake.getAgentCardArgsForCall, struct {
	}{})
	stub := fake.GetAgentCardStub
	fakeReturns := fake.getAgentCardReturns
	fake.recordInvocation("GetAgentCard", []interface{}{})
	fake.getAgentCardMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeA2AServer) GetAgentCardCallCount() int {
	fake.getAgentCardMutex.RLock()
	defer fake.getAgentCardMutex.RUnlock()
	return len(fake.getAgentCardArgsForCall)
}

func (fake *FakeA2AServer) GetAgentCardCalls(stub func() adk.AgentCard) {
	fake.getAgentCardMutex.Lock()
	defer fake.getAgentCardMutex.Unlock()
	fake.GetAgentCardStub = stub
}

func (fake *FakeA2AServer) GetAgentCardReturns(result1 adk.AgentCard) {
	fake.getAgentCardMutex.Lock()
	defer fake.getAgentCardMutex.Unlock()
	fake.GetAgentCardStub = nil
	fake.getAgentCardReturns = struct {
		result1 adk.AgentCard
	}{result1}
}

func (fake *FakeA2AServer) GetAgentCardReturnsOnCall(i int, result1 adk.AgentCard) {
	fake.getAgentCardMutex.Lock()
	defer fake.getAgentCardMutex.Unlock()
	fake.GetAgentCardStub = nil
	if fake.getAgentCardReturnsOnCall == nil {
		fake.getAgentCardReturnsOnCall = make(map[int]struct {
			result1 adk.AgentCard
		})
	}
	fake.getAgentCardReturnsOnCall[i] = struct {
		result1 adk.AgentCard
	}{result1}
}

func (fake *FakeA2AServer) ProcessTask(arg1 context.Context, arg2 *adk.Task, arg3 *adk.Message) (*adk.Task, error) {
	fake.processTaskMutex.Lock()
	ret, specificReturn := fake.processTaskReturnsOnCall[len(fake.processTaskArgsForCall)]
	fake.processTaskArgsForCall = append(fake.processTaskArgsForCall, struct {
		arg1 context.Context
		arg2 *adk.Task
		arg3 *adk.Message
	}{arg1, arg2, arg3})
	stub := fake.ProcessTaskStub
	fakeReturns := fake.processTaskReturns
	fake.recordInvocation("ProcessTask", []interface{}{arg1, arg2, arg3})
	fake.processTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeA2AServer) ProcessTaskCallCount() int {
	fake.processTaskMutex.RLock()
	defer fake.processTaskMutex.RUnlock()
	return len(fake.processTaskArgsForCall)
}

func (fake *FakeA2AServer) ProcessTaskCalls(stub func(context.Context, *adk.Task, *adk.Message) (*adk.Task, error)) {
	fake.processTaskMutex.Lock()
	defer fake.processTaskMutex.Unlock()
	fake.ProcessTaskStub = stub
}

func (fake *FakeA2AServer) ProcessTaskArgsForCall(i int) (context.Context, *adk.Task, *adk.Message) {
	fake.processTaskMutex.RLock()
	defer fake.processTaskMutex.RUnlock()
	argsForCall := fake.processTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeA2AServer) ProcessTaskReturns(result1 *adk.Task, result2 error) {
	fake.processTaskMutex.Lock()
	defer fake.processTaskMutex.Unlock()
	fake.ProcessTaskStub = nil
	fake.processTaskReturns = struct {
		result1 *adk.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeA2AServer) ProcessTaskReturnsOnCall(i int, result1 *adk.Task, result2 error) {
	fake.processTaskMutex.Lock()
	defer fake.processTaskMutex.Unlock()
	fake.ProcessTaskStub = nil
	if fake.processTaskReturnsOnCall == nil {
		fake.processTaskReturnsOnCall = make(map[int]struct {
			result1 *adk.Task
			result2 error
		})
	}
	fake.processTaskReturnsOnCall[i] = struct {
		result1 *adk.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeA2AServer) SetupRouter(arg1 server.OIDCAuthenticator) *gin.Engine {
	fake.setupRouterMutex.Lock()
	ret, specificReturn := fake.setupRouterReturnsOnCall[len(fake.setupRouterArgsForCall)]
	fake.setupRouterArgsForCall = append(fake.setupRouterArgsForCall, struct {
		arg1 server.OIDCAuthenticator
	}{arg1})
	stub := fake.SetupRouterStub
	fakeReturns := fake.setupRouterReturns
	fake.recordInvocation("SetupRouter", []interface{}{arg1})
	fake.setupRouterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeA2AServer) SetupRouterCallCount() int {
	fake.setupRouterMutex.RLock()
	defer fake.setupRouterMutex.RUnlock()
	return len(fake.setupRouterArgsForCall)
}

func (fake *FakeA2AServer) SetupRouterCalls(stub func(server.OIDCAuthenticator) *gin.Engine) {
	fake.setupRouterMutex.Lock()
	defer fake.setupRouterMutex.Unlock()
	fake.SetupRouterStub = stub
}

func (fake *FakeA2AServer) SetupRouterArgsForCall(i int) server.OIDCAuthenticator {
	fake.setupRouterMutex.RLock()
	defer fake.setupRouterMutex.RUnlock()
	argsForCall := fake.setupRouterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeA2AServer) SetupRouterReturns(result1 *gin.Engine) {
	fake.setupRouterMutex.Lock()
	defer fake.setupRouterMutex.Unlock()
	fake.SetupRouterStub = nil
	fake.setupRouterReturns = struct {
		result1 *gin.Engine
	}{result1}
}

func (fake *FakeA2AServer) SetupRouterReturnsOnCall(i int, result1 *gin.Engine) {
	fake.setupRouterMutex.Lock()
	defer fake.setupRouterMutex.Unlock()
	fake.SetupRouterStub = nil
	if fake.setupRouterReturnsOnCall == nil {
		fake.setupRouterReturnsOnCall = make(map[int]struct {
			result1 *gin.Engine
		})
	}
	fake.setupRouterReturnsOnCall[i] = struct {
		result1 *gin.Engine
	}{result1}
}

func (fake *FakeA2AServer) Start(arg1 context.Context) error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.StartStub
	fakeReturns := fake.startReturns
	fake.recordInvocation("Start", []interface{}{arg1})
	fake.startMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeA2AServer) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeA2AServer) StartCalls(stub func(context.Context) error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeA2AServer) StartArgsForCall(i int) context.Context {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	argsForCall := fake.startArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeA2AServer) StartReturns(result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeA2AServer) StartReturnsOnCall(i int, result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeA2AServer) StartTaskProcessor(arg1 context.Context) {
	fake.startTaskProcessorMutex.Lock()
	fake.startTaskProcessorArgsForCall = append(fake.startTaskProcessorArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.StartTaskProcessorStub
	fake.recordInvocation("StartTaskProcessor", []interface{}{arg1})
	fake.startTaskProcessorMutex.Unlock()
	if stub != nil {
		fake.StartTaskProcessorStub(arg1)
	}
}

func (fake *FakeA2AServer) StartTaskProcessorCallCount() int {
	fake.startTaskProcessorMutex.RLock()
	defer fake.startTaskProcessorMutex.RUnlock()
	return len(fake.startTaskProcessorArgsForCall)
}

func (fake *FakeA2AServer) StartTaskProcessorCalls(stub func(context.Context)) {
	fake.startTaskProcessorMutex.Lock()
	defer fake.startTaskProcessorMutex.Unlock()
	fake.StartTaskProcessorStub = stub
}

func (fake *FakeA2AServer) StartTaskProcessorArgsForCall(i int) context.Context {
	fake.startTaskProcessorMutex.RLock()
	defer fake.startTaskProcessorMutex.RUnlock()
	argsForCall := fake.startTaskProcessorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeA2AServer) Stop(arg1 context.Context) error {
	fake.stopMutex.Lock()
	ret, specificReturn := fake.stopReturnsOnCall[len(fake.stopArgsForCall)]
	fake.stopArgsForCall = append(fake.stopArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.StopStub
	fakeReturns := fake.stopReturns
	fake.recordInvocation("Stop", []interface{}{arg1})
	fake.stopMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeA2AServer) StopCallCount() int {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	return len(fake.stopArgsForCall)
}

func (fake *FakeA2AServer) StopCalls(stub func(context.Context) error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = stub
}

func (fake *FakeA2AServer) StopArgsForCall(i int) context.Context {
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	argsForCall := fake.stopArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeA2AServer) StopReturns(result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	fake.stopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeA2AServer) StopReturnsOnCall(i int, result1 error) {
	fake.stopMutex.Lock()
	defer fake.stopMutex.Unlock()
	fake.StopStub = nil
	if fake.stopReturnsOnCall == nil {
		fake.stopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeA2AServer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getAgentCardMutex.RLock()
	defer fake.getAgentCardMutex.RUnlock()
	fake.processTaskMutex.RLock()
	defer fake.processTaskMutex.RUnlock()
	fake.setupRouterMutex.RLock()
	defer fake.setupRouterMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.startTaskProcessorMutex.RLock()
	defer fake.startTaskProcessorMutex.RUnlock()
	fake.stopMutex.RLock()
	defer fake.stopMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeA2AServer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ server.A2AServer = new(FakeA2AServer)
