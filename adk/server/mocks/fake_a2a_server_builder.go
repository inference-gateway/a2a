// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/inference-gateway/a2a/adk/server"
	"go.uber.org/zap"
)

type FakeA2AServerBuilder struct {
	BuildStub        func() server.A2AServer
	buildMutex       sync.RWMutex
	buildArgsForCall []struct {
	}
	buildReturns struct {
		result1 server.A2AServer
	}
	buildReturnsOnCall map[int]struct {
		result1 server.A2AServer
	}
	WithAgentStub        func(server.OpenAICompatibleAgent) server.A2AServerBuilder
	withAgentMutex       sync.RWMutex
	withAgentArgsForCall []struct {
		arg1 server.OpenAICompatibleAgent
	}
	withAgentReturns struct {
		result1 server.A2AServerBuilder
	}
	withAgentReturnsOnCall map[int]struct {
		result1 server.A2AServerBuilder
	}
	WithLoggerStub        func(*zap.Logger) server.A2AServerBuilder
	withLoggerMutex       sync.RWMutex
	withLoggerArgsForCall []struct {
		arg1 *zap.Logger
	}
	withLoggerReturns struct {
		result1 server.A2AServerBuilder
	}
	withLoggerReturnsOnCall map[int]struct {
		result1 server.A2AServerBuilder
	}
	WithTaskHandlerStub        func(server.TaskHandler) server.A2AServerBuilder
	withTaskHandlerMutex       sync.RWMutex
	withTaskHandlerArgsForCall []struct {
		arg1 server.TaskHandler
	}
	withTaskHandlerReturns struct {
		result1 server.A2AServerBuilder
	}
	withTaskHandlerReturnsOnCall map[int]struct {
		result1 server.A2AServerBuilder
	}
	WithTaskResultProcessorStub        func(server.TaskResultProcessor) server.A2AServerBuilder
	withTaskResultProcessorMutex       sync.RWMutex
	withTaskResultProcessorArgsForCall []struct {
		arg1 server.TaskResultProcessor
	}
	withTaskResultProcessorReturns struct {
		result1 server.A2AServerBuilder
	}
	withTaskResultProcessorReturnsOnCall map[int]struct {
		result1 server.A2AServerBuilder
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeA2AServerBuilder) Build() server.A2AServer {
	fake.buildMutex.Lock()
	ret, specificReturn := fake.buildReturnsOnCall[len(fake.buildArgsForCall)]
	fake.buildArgsForCall = append(fake.buildArgsForCall, struct {
	}{})
	stub := fake.BuildStub
	fakeReturns := fake.buildReturns
	fake.recordInvocation("Build", []interface{}{})
	fake.buildMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeA2AServerBuilder) BuildCallCount() int {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	return len(fake.buildArgsForCall)
}

func (fake *FakeA2AServerBuilder) BuildCalls(stub func() server.A2AServer) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = stub
}

func (fake *FakeA2AServerBuilder) BuildReturns(result1 server.A2AServer) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = nil
	fake.buildReturns = struct {
		result1 server.A2AServer
	}{result1}
}

func (fake *FakeA2AServerBuilder) BuildReturnsOnCall(i int, result1 server.A2AServer) {
	fake.buildMutex.Lock()
	defer fake.buildMutex.Unlock()
	fake.BuildStub = nil
	if fake.buildReturnsOnCall == nil {
		fake.buildReturnsOnCall = make(map[int]struct {
			result1 server.A2AServer
		})
	}
	fake.buildReturnsOnCall[i] = struct {
		result1 server.A2AServer
	}{result1}
}

func (fake *FakeA2AServerBuilder) WithAgent(arg1 server.OpenAICompatibleAgent) server.A2AServerBuilder {
	fake.withAgentMutex.Lock()
	ret, specificReturn := fake.withAgentReturnsOnCall[len(fake.withAgentArgsForCall)]
	fake.withAgentArgsForCall = append(fake.withAgentArgsForCall, struct {
		arg1 server.OpenAICompatibleAgent
	}{arg1})
	stub := fake.WithAgentStub
	fakeReturns := fake.withAgentReturns
	fake.recordInvocation("WithAgent", []interface{}{arg1})
	fake.withAgentMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeA2AServerBuilder) WithAgentCallCount() int {
	fake.withAgentMutex.RLock()
	defer fake.withAgentMutex.RUnlock()
	return len(fake.withAgentArgsForCall)
}

func (fake *FakeA2AServerBuilder) WithAgentCalls(stub func(server.OpenAICompatibleAgent) server.A2AServerBuilder) {
	fake.withAgentMutex.Lock()
	defer fake.withAgentMutex.Unlock()
	fake.WithAgentStub = stub
}

func (fake *FakeA2AServerBuilder) WithAgentArgsForCall(i int) server.OpenAICompatibleAgent {
	fake.withAgentMutex.RLock()
	defer fake.withAgentMutex.RUnlock()
	argsForCall := fake.withAgentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeA2AServerBuilder) WithAgentReturns(result1 server.A2AServerBuilder) {
	fake.withAgentMutex.Lock()
	defer fake.withAgentMutex.Unlock()
	fake.WithAgentStub = nil
	fake.withAgentReturns = struct {
		result1 server.A2AServerBuilder
	}{result1}
}

func (fake *FakeA2AServerBuilder) WithAgentReturnsOnCall(i int, result1 server.A2AServerBuilder) {
	fake.withAgentMutex.Lock()
	defer fake.withAgentMutex.Unlock()
	fake.WithAgentStub = nil
	if fake.withAgentReturnsOnCall == nil {
		fake.withAgentReturnsOnCall = make(map[int]struct {
			result1 server.A2AServerBuilder
		})
	}
	fake.withAgentReturnsOnCall[i] = struct {
		result1 server.A2AServerBuilder
	}{result1}
}

func (fake *FakeA2AServerBuilder) WithLogger(arg1 *zap.Logger) server.A2AServerBuilder {
	fake.withLoggerMutex.Lock()
	ret, specificReturn := fake.withLoggerReturnsOnCall[len(fake.withLoggerArgsForCall)]
	fake.withLoggerArgsForCall = append(fake.withLoggerArgsForCall, struct {
		arg1 *zap.Logger
	}{arg1})
	stub := fake.WithLoggerStub
	fakeReturns := fake.withLoggerReturns
	fake.recordInvocation("WithLogger", []interface{}{arg1})
	fake.withLoggerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeA2AServerBuilder) WithLoggerCallCount() int {
	fake.withLoggerMutex.RLock()
	defer fake.withLoggerMutex.RUnlock()
	return len(fake.withLoggerArgsForCall)
}

func (fake *FakeA2AServerBuilder) WithLoggerCalls(stub func(*zap.Logger) server.A2AServerBuilder) {
	fake.withLoggerMutex.Lock()
	defer fake.withLoggerMutex.Unlock()
	fake.WithLoggerStub = stub
}

func (fake *FakeA2AServerBuilder) WithLoggerArgsForCall(i int) *zap.Logger {
	fake.withLoggerMutex.RLock()
	defer fake.withLoggerMutex.RUnlock()
	argsForCall := fake.withLoggerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeA2AServerBuilder) WithLoggerReturns(result1 server.A2AServerBuilder) {
	fake.withLoggerMutex.Lock()
	defer fake.withLoggerMutex.Unlock()
	fake.WithLoggerStub = nil
	fake.withLoggerReturns = struct {
		result1 server.A2AServerBuilder
	}{result1}
}

func (fake *FakeA2AServerBuilder) WithLoggerReturnsOnCall(i int, result1 server.A2AServerBuilder) {
	fake.withLoggerMutex.Lock()
	defer fake.withLoggerMutex.Unlock()
	fake.WithLoggerStub = nil
	if fake.withLoggerReturnsOnCall == nil {
		fake.withLoggerReturnsOnCall = make(map[int]struct {
			result1 server.A2AServerBuilder
		})
	}
	fake.withLoggerReturnsOnCall[i] = struct {
		result1 server.A2AServerBuilder
	}{result1}
}

func (fake *FakeA2AServerBuilder) WithTaskHandler(arg1 server.TaskHandler) server.A2AServerBuilder {
	fake.withTaskHandlerMutex.Lock()
	ret, specificReturn := fake.withTaskHandlerReturnsOnCall[len(fake.withTaskHandlerArgsForCall)]
	fake.withTaskHandlerArgsForCall = append(fake.withTaskHandlerArgsForCall, struct {
		arg1 server.TaskHandler
	}{arg1})
	stub := fake.WithTaskHandlerStub
	fakeReturns := fake.withTaskHandlerReturns
	fake.recordInvocation("WithTaskHandler", []interface{}{arg1})
	fake.withTaskHandlerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeA2AServerBuilder) WithTaskHandlerCallCount() int {
	fake.withTaskHandlerMutex.RLock()
	defer fake.withTaskHandlerMutex.RUnlock()
	return len(fake.withTaskHandlerArgsForCall)
}

func (fake *FakeA2AServerBuilder) WithTaskHandlerCalls(stub func(server.TaskHandler) server.A2AServerBuilder) {
	fake.withTaskHandlerMutex.Lock()
	defer fake.withTaskHandlerMutex.Unlock()
	fake.WithTaskHandlerStub = stub
}

func (fake *FakeA2AServerBuilder) WithTaskHandlerArgsForCall(i int) server.TaskHandler {
	fake.withTaskHandlerMutex.RLock()
	defer fake.withTaskHandlerMutex.RUnlock()
	argsForCall := fake.withTaskHandlerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeA2AServerBuilder) WithTaskHandlerReturns(result1 server.A2AServerBuilder) {
	fake.withTaskHandlerMutex.Lock()
	defer fake.withTaskHandlerMutex.Unlock()
	fake.WithTaskHandlerStub = nil
	fake.withTaskHandlerReturns = struct {
		result1 server.A2AServerBuilder
	}{result1}
}

func (fake *FakeA2AServerBuilder) WithTaskHandlerReturnsOnCall(i int, result1 server.A2AServerBuilder) {
	fake.withTaskHandlerMutex.Lock()
	defer fake.withTaskHandlerMutex.Unlock()
	fake.WithTaskHandlerStub = nil
	if fake.withTaskHandlerReturnsOnCall == nil {
		fake.withTaskHandlerReturnsOnCall = make(map[int]struct {
			result1 server.A2AServerBuilder
		})
	}
	fake.withTaskHandlerReturnsOnCall[i] = struct {
		result1 server.A2AServerBuilder
	}{result1}
}

func (fake *FakeA2AServerBuilder) WithTaskResultProcessor(arg1 server.TaskResultProcessor) server.A2AServerBuilder {
	fake.withTaskResultProcessorMutex.Lock()
	ret, specificReturn := fake.withTaskResultProcessorReturnsOnCall[len(fake.withTaskResultProcessorArgsForCall)]
	fake.withTaskResultProcessorArgsForCall = append(fake.withTaskResultProcessorArgsForCall, struct {
		arg1 server.TaskResultProcessor
	}{arg1})
	stub := fake.WithTaskResultProcessorStub
	fakeReturns := fake.withTaskResultProcessorReturns
	fake.recordInvocation("WithTaskResultProcessor", []interface{}{arg1})
	fake.withTaskResultProcessorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeA2AServerBuilder) WithTaskResultProcessorCallCount() int {
	fake.withTaskResultProcessorMutex.RLock()
	defer fake.withTaskResultProcessorMutex.RUnlock()
	return len(fake.withTaskResultProcessorArgsForCall)
}

func (fake *FakeA2AServerBuilder) WithTaskResultProcessorCalls(stub func(server.TaskResultProcessor) server.A2AServerBuilder) {
	fake.withTaskResultProcessorMutex.Lock()
	defer fake.withTaskResultProcessorMutex.Unlock()
	fake.WithTaskResultProcessorStub = stub
}

func (fake *FakeA2AServerBuilder) WithTaskResultProcessorArgsForCall(i int) server.TaskResultProcessor {
	fake.withTaskResultProcessorMutex.RLock()
	defer fake.withTaskResultProcessorMutex.RUnlock()
	argsForCall := fake.withTaskResultProcessorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeA2AServerBuilder) WithTaskResultProcessorReturns(result1 server.A2AServerBuilder) {
	fake.withTaskResultProcessorMutex.Lock()
	defer fake.withTaskResultProcessorMutex.Unlock()
	fake.WithTaskResultProcessorStub = nil
	fake.withTaskResultProcessorReturns = struct {
		result1 server.A2AServerBuilder
	}{result1}
}

func (fake *FakeA2AServerBuilder) WithTaskResultProcessorReturnsOnCall(i int, result1 server.A2AServerBuilder) {
	fake.withTaskResultProcessorMutex.Lock()
	defer fake.withTaskResultProcessorMutex.Unlock()
	fake.WithTaskResultProcessorStub = nil
	if fake.withTaskResultProcessorReturnsOnCall == nil {
		fake.withTaskResultProcessorReturnsOnCall = make(map[int]struct {
			result1 server.A2AServerBuilder
		})
	}
	fake.withTaskResultProcessorReturnsOnCall[i] = struct {
		result1 server.A2AServerBuilder
	}{result1}
}

func (fake *FakeA2AServerBuilder) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	fake.withAgentMutex.RLock()
	defer fake.withAgentMutex.RUnlock()
	fake.withLoggerMutex.RLock()
	defer fake.withLoggerMutex.RUnlock()
	fake.withTaskHandlerMutex.RLock()
	defer fake.withTaskHandlerMutex.RUnlock()
	fake.withTaskResultProcessorMutex.RLock()
	defer fake.withTaskResultProcessorMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeA2AServerBuilder) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ server.A2AServerBuilder = new(FakeA2AServerBuilder)
