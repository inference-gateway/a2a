// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/inference-gateway/a2a/adk"
	"github.com/inference-gateway/a2a/adk/server"
)

type FakeTaskManager struct {
	CancelTaskStub        func(string) error
	cancelTaskMutex       sync.RWMutex
	cancelTaskArgsForCall []struct {
		arg1 string
	}
	cancelTaskReturns struct {
		result1 error
	}
	cancelTaskReturnsOnCall map[int]struct {
		result1 error
	}
	CleanupCompletedTasksStub        func()
	cleanupCompletedTasksMutex       sync.RWMutex
	cleanupCompletedTasksArgsForCall []struct {
	}
	CreateTaskStub        func(string, adk.TaskState, *adk.Message) *adk.Task
	createTaskMutex       sync.RWMutex
	createTaskArgsForCall []struct {
		arg1 string
		arg2 adk.TaskState
		arg3 *adk.Message
	}
	createTaskReturns struct {
		result1 *adk.Task
	}
	createTaskReturnsOnCall map[int]struct {
		result1 *adk.Task
	}
	GetTaskStub        func(string) (*adk.Task, bool)
	getTaskMutex       sync.RWMutex
	getTaskArgsForCall []struct {
		arg1 string
	}
	getTaskReturns struct {
		result1 *adk.Task
		result2 bool
	}
	getTaskReturnsOnCall map[int]struct {
		result1 *adk.Task
		result2 bool
	}
	UpdateTaskStub        func(string, adk.TaskState, *adk.Message) error
	updateTaskMutex       sync.RWMutex
	updateTaskArgsForCall []struct {
		arg1 string
		arg2 adk.TaskState
		arg3 *adk.Message
	}
	updateTaskReturns struct {
		result1 error
	}
	updateTaskReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTaskManager) CancelTask(arg1 string) error {
	fake.cancelTaskMutex.Lock()
	ret, specificReturn := fake.cancelTaskReturnsOnCall[len(fake.cancelTaskArgsForCall)]
	fake.cancelTaskArgsForCall = append(fake.cancelTaskArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CancelTaskStub
	fakeReturns := fake.cancelTaskReturns
	fake.recordInvocation("CancelTask", []interface{}{arg1})
	fake.cancelTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskManager) CancelTaskCallCount() int {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return len(fake.cancelTaskArgsForCall)
}

func (fake *FakeTaskManager) CancelTaskCalls(stub func(string) error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = stub
}

func (fake *FakeTaskManager) CancelTaskArgsForCall(i int) string {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	argsForCall := fake.cancelTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskManager) CancelTaskReturns(result1 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	fake.cancelTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) CancelTaskReturnsOnCall(i int, result1 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	if fake.cancelTaskReturnsOnCall == nil {
		fake.cancelTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) CleanupCompletedTasks() {
	fake.cleanupCompletedTasksMutex.Lock()
	fake.cleanupCompletedTasksArgsForCall = append(fake.cleanupCompletedTasksArgsForCall, struct {
	}{})
	stub := fake.CleanupCompletedTasksStub
	fake.recordInvocation("CleanupCompletedTasks", []interface{}{})
	fake.cleanupCompletedTasksMutex.Unlock()
	if stub != nil {
		fake.CleanupCompletedTasksStub()
	}
}

func (fake *FakeTaskManager) CleanupCompletedTasksCallCount() int {
	fake.cleanupCompletedTasksMutex.RLock()
	defer fake.cleanupCompletedTasksMutex.RUnlock()
	return len(fake.cleanupCompletedTasksArgsForCall)
}

func (fake *FakeTaskManager) CleanupCompletedTasksCalls(stub func()) {
	fake.cleanupCompletedTasksMutex.Lock()
	defer fake.cleanupCompletedTasksMutex.Unlock()
	fake.CleanupCompletedTasksStub = stub
}

func (fake *FakeTaskManager) CreateTask(arg1 string, arg2 adk.TaskState, arg3 *adk.Message) *adk.Task {
	fake.createTaskMutex.Lock()
	ret, specificReturn := fake.createTaskReturnsOnCall[len(fake.createTaskArgsForCall)]
	fake.createTaskArgsForCall = append(fake.createTaskArgsForCall, struct {
		arg1 string
		arg2 adk.TaskState
		arg3 *adk.Message
	}{arg1, arg2, arg3})
	stub := fake.CreateTaskStub
	fakeReturns := fake.createTaskReturns
	fake.recordInvocation("CreateTask", []interface{}{arg1, arg2, arg3})
	fake.createTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskManager) CreateTaskCallCount() int {
	fake.createTaskMutex.RLock()
	defer fake.createTaskMutex.RUnlock()
	return len(fake.createTaskArgsForCall)
}

func (fake *FakeTaskManager) CreateTaskCalls(stub func(string, adk.TaskState, *adk.Message) *adk.Task) {
	fake.createTaskMutex.Lock()
	defer fake.createTaskMutex.Unlock()
	fake.CreateTaskStub = stub
}

func (fake *FakeTaskManager) CreateTaskArgsForCall(i int) (string, adk.TaskState, *adk.Message) {
	fake.createTaskMutex.RLock()
	defer fake.createTaskMutex.RUnlock()
	argsForCall := fake.createTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTaskManager) CreateTaskReturns(result1 *adk.Task) {
	fake.createTaskMutex.Lock()
	defer fake.createTaskMutex.Unlock()
	fake.CreateTaskStub = nil
	fake.createTaskReturns = struct {
		result1 *adk.Task
	}{result1}
}

func (fake *FakeTaskManager) CreateTaskReturnsOnCall(i int, result1 *adk.Task) {
	fake.createTaskMutex.Lock()
	defer fake.createTaskMutex.Unlock()
	fake.CreateTaskStub = nil
	if fake.createTaskReturnsOnCall == nil {
		fake.createTaskReturnsOnCall = make(map[int]struct {
			result1 *adk.Task
		})
	}
	fake.createTaskReturnsOnCall[i] = struct {
		result1 *adk.Task
	}{result1}
}

func (fake *FakeTaskManager) GetTask(arg1 string) (*adk.Task, bool) {
	fake.getTaskMutex.Lock()
	ret, specificReturn := fake.getTaskReturnsOnCall[len(fake.getTaskArgsForCall)]
	fake.getTaskArgsForCall = append(fake.getTaskArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTaskStub
	fakeReturns := fake.getTaskReturns
	fake.recordInvocation("GetTask", []interface{}{arg1})
	fake.getTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTaskManager) GetTaskCallCount() int {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	return len(fake.getTaskArgsForCall)
}

func (fake *FakeTaskManager) GetTaskCalls(stub func(string) (*adk.Task, bool)) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = stub
}

func (fake *FakeTaskManager) GetTaskArgsForCall(i int) string {
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	argsForCall := fake.getTaskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTaskManager) GetTaskReturns(result1 *adk.Task, result2 bool) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	fake.getTaskReturns = struct {
		result1 *adk.Task
		result2 bool
	}{result1, result2}
}

func (fake *FakeTaskManager) GetTaskReturnsOnCall(i int, result1 *adk.Task, result2 bool) {
	fake.getTaskMutex.Lock()
	defer fake.getTaskMutex.Unlock()
	fake.GetTaskStub = nil
	if fake.getTaskReturnsOnCall == nil {
		fake.getTaskReturnsOnCall = make(map[int]struct {
			result1 *adk.Task
			result2 bool
		})
	}
	fake.getTaskReturnsOnCall[i] = struct {
		result1 *adk.Task
		result2 bool
	}{result1, result2}
}

func (fake *FakeTaskManager) UpdateTask(arg1 string, arg2 adk.TaskState, arg3 *adk.Message) error {
	fake.updateTaskMutex.Lock()
	ret, specificReturn := fake.updateTaskReturnsOnCall[len(fake.updateTaskArgsForCall)]
	fake.updateTaskArgsForCall = append(fake.updateTaskArgsForCall, struct {
		arg1 string
		arg2 adk.TaskState
		arg3 *adk.Message
	}{arg1, arg2, arg3})
	stub := fake.UpdateTaskStub
	fakeReturns := fake.updateTaskReturns
	fake.recordInvocation("UpdateTask", []interface{}{arg1, arg2, arg3})
	fake.updateTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTaskManager) UpdateTaskCallCount() int {
	fake.updateTaskMutex.RLock()
	defer fake.updateTaskMutex.RUnlock()
	return len(fake.updateTaskArgsForCall)
}

func (fake *FakeTaskManager) UpdateTaskCalls(stub func(string, adk.TaskState, *adk.Message) error) {
	fake.updateTaskMutex.Lock()
	defer fake.updateTaskMutex.Unlock()
	fake.UpdateTaskStub = stub
}

func (fake *FakeTaskManager) UpdateTaskArgsForCall(i int) (string, adk.TaskState, *adk.Message) {
	fake.updateTaskMutex.RLock()
	defer fake.updateTaskMutex.RUnlock()
	argsForCall := fake.updateTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTaskManager) UpdateTaskReturns(result1 error) {
	fake.updateTaskMutex.Lock()
	defer fake.updateTaskMutex.Unlock()
	fake.UpdateTaskStub = nil
	fake.updateTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) UpdateTaskReturnsOnCall(i int, result1 error) {
	fake.updateTaskMutex.Lock()
	defer fake.updateTaskMutex.Unlock()
	fake.UpdateTaskStub = nil
	if fake.updateTaskReturnsOnCall == nil {
		fake.updateTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTaskManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	fake.cleanupCompletedTasksMutex.RLock()
	defer fake.cleanupCompletedTasksMutex.RUnlock()
	fake.createTaskMutex.RLock()
	defer fake.createTaskMutex.RUnlock()
	fake.getTaskMutex.RLock()
	defer fake.getTaskMutex.RUnlock()
	fake.updateTaskMutex.RLock()
	defer fake.updateTaskMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTaskManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ server.TaskManager = new(FakeTaskManager)
